"""
Network Transport Layer

Handles actual network communication between nodes using gRPC.
"""

import asyncio
import grpc
import json
import logging
from typing import Dict, Any, Optional, Callable, List
from datetime import datetime
from dataclasses import dataclass, asdict
from abc import ABC, abstractmethod
import socket

from grpc import aio
from concurrent import futures

# Import protobuf messages (to be generated)
try:
    from . import consensus_pb2
    from . import consensus_pb2_grpc
except ImportError:
    # Will be generated by compile_protos.sh
    consensus_pb2 = None
    consensus_pb2_grpc = None


@dataclass
class Message:
    """Network message wrapper"""
    message_id: str
    message_type: str
    sender_id: str
    recipient_id: str
    payload: Dict[str, Any]
    timestamp: datetime
    
    def to_proto(self):
        """Convert to protobuf message"""
        if consensus_pb2:
            return consensus_pb2.NetworkMessage(
                message_id=self.message_id,
                message_type=self.message_type,
                sender_id=self.sender_id,
                recipient_id=self.recipient_id,
                payload=json.dumps(self.payload),
                timestamp=self.timestamp.isoformat()
            )
        else:
            # Fallback for when protos aren't compiled yet
            return {
                "message_id": self.message_id,
                "message_type": self.message_type,
                "sender_id": self.sender_id,
                "recipient_id": self.recipient_id,
                "payload": self.payload,
                "timestamp": self.timestamp.isoformat()
            }
    
    @classmethod
    def from_proto(cls, proto_msg):
        """Create from protobuf message"""
        if hasattr(proto_msg, 'payload'):
            # From actual protobuf
            return cls(
                message_id=proto_msg.message_id,
                message_type=proto_msg.message_type,
                sender_id=proto_msg.sender_id,
                recipient_id=proto_msg.recipient_id,
                payload=json.loads(proto_msg.payload),
                timestamp=datetime.fromisoformat(proto_msg.timestamp)
            )
        else:
            # From dict fallback
            return cls(
                message_id=proto_msg["message_id"],
                message_type=proto_msg["message_type"],
                sender_id=proto_msg["sender_id"],
                recipient_id=proto_msg["recipient_id"],
                payload=proto_msg["payload"],
                timestamp=datetime.fromisoformat(proto_msg["timestamp"])
            )


class NetworkTransport(ABC):
    """Abstract base class for network transport"""
    
    @abstractmethod
    async def start(self, host: str, port: int):
        """Start the transport server"""
        pass
    
    @abstractmethod
    async def stop(self):
        """Stop the transport server"""
        pass
    
    @abstractmethod
    async def send_message(self, target_address: str, message: Message) -> bool:
        """Send a message to a target node"""
        pass
    
    @abstractmethod
    async def broadcast_message(self, message: Message, targets: List[str]) -> Dict[str, bool]:
        """Broadcast a message to multiple nodes"""
        pass
    
    @abstractmethod
    def register_handler(self, message_type: str, handler: Callable):
        """Register a message handler"""
        pass


class GRPCTransport(NetworkTransport):
    """gRPC-based network transport implementation"""
    
    def __init__(self, node_id: str, max_message_size: int = 10 * 1024 * 1024):
        self.node_id = node_id
        self.max_message_size = max_message_size
        self.logger = logging.getLogger(f"{__name__}.{node_id}")
        
        self.server: Optional[aio.Server] = None
        self.channel_pool: Dict[str, aio.Channel] = {}
        self.handlers: Dict[str, Callable] = {}
        
        self.host: Optional[str] = None
        self.port: Optional[int] = None
        self.is_running = False
        
        # Metrics
        self.metrics = {
            "messages_sent": 0,
            "messages_received": 0,
            "messages_failed": 0,
            "bytes_sent": 0,
            "bytes_received": 0
        }
    
    async def start(self, host: str, port: int):
        """Start the gRPC server"""
        self.host = host
        self.port = port
        
        # Create gRPC server
        self.server = aio.server(
            futures.ThreadPoolExecutor(max_workers=10),
            options=[
                ('grpc.max_send_message_length', self.max_message_size),
                ('grpc.max_receive_message_length', self.max_message_size),
            ]
        )
        
        # Add service
        if consensus_pb2_grpc:
            consensus_pb2_grpc.add_ConsensusServiceServicer_to_server(
                ConsensusServicer(self), self.server
            )
        
        # Start server
        listen_addr = f'{host}:{port}'
        self.server.add_insecure_port(listen_addr)
        
        await self.server.start()
        self.is_running = True
        
        self.logger.info(f"gRPC server started on {listen_addr}")
        
        # Keep server running
        asyncio.create_task(self._serve())
    
    async def _serve(self):
        """Keep server running"""
        try:
            await self.server.wait_for_termination()
        except asyncio.CancelledError:
            pass
    
    async def stop(self):
        """Stop the gRPC server"""
        self.is_running = False
        
        # Close all channels
        for channel in self.channel_pool.values():
            await channel.close()
        self.channel_pool.clear()
        
        # Stop server
        if self.server:
            await self.server.stop(grace=5.0)
            self.server = None
            
        self.logger.info("gRPC server stopped")
    
    async def send_message(self, target_address: str, message: Message) -> bool:
        """Send a message to a target node"""
        try:
            # Get or create channel
            channel = await self._get_channel(target_address)
            
            if consensus_pb2_grpc:
                # Use gRPC stub
                stub = consensus_pb2_grpc.ConsensusServiceStub(channel)
                
                # Convert to proto
                proto_msg = message.to_proto()
                
                # Send message
                response = await stub.SendMessage(proto_msg)
                
                # Update metrics
                self.metrics["messages_sent"] += 1
                self.metrics["bytes_sent"] += len(json.dumps(message.payload))
                
                return response.success
            else:
                # Fallback - just log
                self.logger.warning("gRPC protos not compiled, cannot send message")
                return False
                
        except grpc.RpcError as e:
            self.logger.error(f"Failed to send message to {target_address}: {e}")
            self.metrics["messages_failed"] += 1
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error sending message: {e}")
            self.metrics["messages_failed"] += 1
            return False
    
    async def broadcast_message(self, message: Message, targets: List[str]) -> Dict[str, bool]:
        """Broadcast a message to multiple nodes"""
        results = {}
        
        # Send to all targets concurrently
        tasks = []
        for target in targets:
            task = asyncio.create_task(self.send_message(target, message))
            tasks.append((target, task))
        
        # Wait for all sends to complete
        for target, task in tasks:
            try:
                success = await task
                results[target] = success
            except Exception as e:
                self.logger.error(f"Failed to send to {target}: {e}")
                results[target] = False
        
        return results
    
    def register_handler(self, message_type: str, handler: Callable):
        """Register a message handler"""
        self.handlers[message_type] = handler
        self.logger.info(f"Registered handler for message type: {message_type}")
    
    async def _get_channel(self, address: str) -> aio.Channel:
        """Get or create a gRPC channel"""
        if address not in self.channel_pool:
            # Create new channel
            channel = aio.insecure_channel(
                address,
                options=[
                    ('grpc.max_send_message_length', self.max_message_size),
                    ('grpc.max_receive_message_length', self.max_message_size),
                    ('grpc.keepalive_time_ms', 10000),
                    ('grpc.keepalive_timeout_ms', 5000),
                    ('grpc.keepalive_permit_without_calls', True),
                    ('grpc.http2.max_pings_without_data', 0),
                ]
            )
            self.channel_pool[address] = channel
            
        return self.channel_pool[address]
    
    async def handle_incoming_message(self, message: Message):
        """Handle an incoming message"""
        self.metrics["messages_received"] += 1
        self.metrics["bytes_received"] += len(json.dumps(message.payload))
        
        # Find handler
        handler = self.handlers.get(message.message_type)
        if handler:
            try:
                # Call handler
                if asyncio.iscoroutinefunction(handler):
                    await handler(message)
                else:
                    handler(message)
            except Exception as e:
                self.logger.error(f"Handler error for {message.message_type}: {e}")
        else:
            self.logger.warning(f"No handler for message type: {message.message_type}")
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get transport metrics"""
        return {
            **self.metrics,
            "active_channels": len(self.channel_pool),
            "registered_handlers": len(self.handlers),
            "is_running": self.is_running
        }
    
    def get_local_address(self) -> str:
        """Get local server address"""
        if self.host and self.port:
            # Handle special case for 0.0.0.0
            host = self.host
            if host == "0.0.0.0":
                # Get actual IP
                host = socket.gethostbyname(socket.gethostname())
            return f"{host}:{self.port}"
        return ""


class ConsensusServicer:
    """gRPC service implementation"""
    
    def __init__(self, transport: GRPCTransport):
        self.transport = transport
    
    async def SendMessage(self, request, context):
        """Handle incoming message"""
        try:
            # Convert from proto
            message = Message.from_proto(request)
            
            # Handle message
            await self.transport.handle_incoming_message(message)
            
            # Return success
            if consensus_pb2:
                return consensus_pb2.MessageResponse(success=True)
            else:
                return {"success": True}
                
        except Exception as e:
            logging.error(f"Error handling message: {e}")
            if consensus_pb2:
                return consensus_pb2.MessageResponse(success=False, error=str(e))
            else:
                return {"success": False, "error": str(e)}